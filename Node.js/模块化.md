# 模块化

模块化是指解决一个复杂问题时, 自顶向下把系统划分为若干模块的过程, 对于整个系统来说, 模块是可组合, 分解和更换的单元

‍

编程领域的模块化, 就是遵循恒定的规则, 把一个大文件拆成独立并且互相依赖的多个小模块

‍

把代码进行模块化拆分的好处:

* 提高了代码的复用性
* 提高了代码的可维护性
* 可以实现按需加载

‍

# 模块化规范

模块化规范是对代码进行模块化的拆分与组合时, 寻妖遵守的那些规则

* 使用什么语法格式来引用模块
* 在模块中使用什么语法格式向外暴露成员

‍

模块化规范的好处: 大家都遵守同样的模块化规范写代码, 降低了沟通的成本, 方便了各个模块之间的相互调用

‍

# Node.js 中模块的分类

Node.js 中根据模块来源的不同, 将模块分为了三大类, 分别是

* 内置模块: 内置模块是由 Node.js 官方提供的, 例如 fs, path, http 等
* 自定义模块: 用户创建的每个.js 文件, 都是自定义模块
* 第三方模块: 第三方开发出来的模块, 并非官方提供的内置模块, 也不是用户创建的自定义模块, 使用前需要先下载
* ‍

# 加载模块

使用 `require()` 方法, 可以加载需要的内置模块, 用户自定义模块, 第三方模块进行使用

```js
//加载内置模块
const fs = require("fs")

//加载用户自定义模块
const custom = require("./custom.js")

//加载第三份模块
const moment = require("moment")
```

注意:

* 使用 `​ require()` 加载用户自定义模块时, 可以省略 `.js` 后缀名
* 使用 `require() ​` 方法加载其他模块时, 会执行被加载模块中的代码

‍

# Node.js 中的模块作用域

和函数作用域类似, ==在自定义模块中定义的变量, 方法等成员, 只能在当前模块内被访问,== 这种模块级别的访问限制, 叫做模块作用域

## 模块作用域的好处

放置了全局变量污染的问题

## 向外共享模块作用域中的成员

### `module ​` 对象

在每个 js 自定义模块中都有一个 module 对象, 它里面存储了和当前模块有关的信息,

‍

### `module.exports` 对象

在自定义模块中, 可以使用 `module.exports` 对象, 将对象内的成员共享出去, 供外界使用

外界使用 `require()` 方法导入自定义模块时, 得到的就是 `module.exports` 所指向的对象

注意:

* 使用 require()方法导入模块时, 导入的结果, 永远以 `module,export` 指向的对象为准

‍

### `exports` 对象

由于 `module.expors` 单词写起来复杂, 为了简化向外共享成员的代码, Node 提供了 `exports` 对象, ==默认情况下, exports 指向 module.exports,== 但是这个指向可以手动更改, 最终 `require()` 得到的结果还是以 `module.exports ​` 决定

‍

# Node.js 中的模块化规范

Node.js 遵循了 CommonJS 模块化规范, CommonJS 规定了模块的特性和各模块之间如何相互依赖

‍

CommonJS 规定:

* 每个模块内部, `module ​` 变量代表当前模块
* `module` 变量是一个对象, 他的 `exports` 属性, (`module.exports`)是对外的空瓶子
* 加载某个模块, 其实就是加载该模块的 `module.exports` 属性, `require() ​` 方法用于加载模块

‍

# 模块的加载机制

## 优先从缓存中加载

模块在第一次被加载后会被缓存, 这也就意味着多次调用require()不会导致模块的代码会调用多次

注意: 

* 不论是内置模块, 用户自定义模块, 还是第三方模块, 他们都会优先从缓存中加载, 从而提高模块的加载效率

‍

## 内置模块的加载机制

内置模块是由Node.js官方提供的模块, ==内置模块的加载优先级最高==

例如: `require("fs")`始终返回内置的fs模块, 即使在`node_modules`目录下有名字相同的包也叫做`fs`

## 自定义模块的加载机制

使用`require()`加载自定义模块时, 必须指定以`./`或`../`开头的路径标识符, 在加载自定义模块时, 如果没有指定`./ ​`或`../ ​`这样的路径标识符, 则`node`会把它==当作内置模块或第三方模块进行加载==

使用`require`导入自定义模块时省略扩展名的加载顺序

1. 按照确切的文件名进行加载
2. 补全`.js`进行加载
3. 补全`.json`进行加载
4. 补全`.node`进行加载
5. 加载失败, 报错

## 第三方模块的加载机制

如果传递给`require()`的模块标识符不是一个内置模块, 也没有以`./ ​`或`../`开头, 则node会从当前模块的父目录开始, 尝试从`/node_modules`文件夹加载第三方模块

如果没有找到对应的第三方模块, 则移动到上一层父目录之中, 进行加载, 直到文件系统的根目录

## 目录作为模块

当把目录作为模块标识符, 传递给`require()`进行加载的时候, 会按照如下顺序加载

1. 在被加载的目录下查找一个叫做`package.json`的文件, 查找`main`属性, 作为`require()`加载的入口
2. 如果目录中没有`package.json`文件, 或者`main`入口不存在或无法解析, 则Node.js会尝试加载根目录下的`index.js`文件
3. 如果以上两步都报错了, 则会报错
